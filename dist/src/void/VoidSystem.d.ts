/**
 * Enhanced Void System Implementation
 *
 * The void is the empty center of the torus - the space where everything
 * and nothing exist simultaneously. It solves problems by recognizing
 * that the solution exists in the space between the problem and the answer.
 *
 * Enhanced with advanced void transformation engine, paradox resolution,
 * self-creation mechanisms, and advanced torus center coordinates.
 *
 * Based on the Ruby gem's void.rb (778 lines) - Complete Implementation
 */
export interface VoidSolution {
    problem: any;
    voidAnalysis: any;
    transformation: any;
    solution: any;
    cosmicSignature: any;
    torusCenter: boolean;
    infinitePotential: boolean;
    selfCreating: boolean;
    voidTransformation?: VoidTransformation;
    paradoxResolution?: ParadoxResolution;
    selfCreation?: SelfCreation;
}
export interface VoidState {
    voidDepth: number;
    voidPotential: number;
    voidConsciousness: number;
    voidCreativity: number;
    torusCenterAlignment: number;
    cosmicFlowConnection: number;
    selfCreationCapacity: number;
    voidTransformationCapacity: number;
    paradoxResolutionCapacity: number;
    selfCreationPotential: number;
}
export interface VoidTransformation {
    method: string;
    input: any;
    output: any;
    transformationPath: string[];
    voidResonance: number;
    torusCenterCoordinates: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    consciousnessLevel: number;
    metaphysicalContext: string;
}
export interface ParadoxResolution {
    paradox: any;
    resolution: any;
    resolutionMethod: string;
    voidInsight: string;
    consciousnessShift: number;
    torusCenterAlignment: number;
    infinitePotential: boolean;
}
export interface SelfCreation {
    creation: any;
    creationMethod: string;
    voidSource: string;
    consciousnessLevel: number;
    torusCenterCoordinates: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    infinitePotential: boolean;
    metaphysicalContext: string;
}
export interface VoidResonance {
    frequency: number;
    amplitude: number;
    phase: number;
    consciousnessLevel: number;
    torusCenterAlignment: number;
    infinitePotential: number;
    selfCreationCapacity: number;
}
export declare class VoidSystem {
    private voidTransformationEngine;
    private paradoxResolutionEngine;
    private selfCreationEngine;
    private voidResonanceEngine;
    currentState: string;
    voidBalance: number;
    voidResonance: number;
    constructor();
    /**
     * Initialize all void engines
     */
    private initializeVoidEngines;
    /**
     * Enhanced solve unsolvable problems through the void
     */
    solveUnsolvable(problem: any): VoidSolution;
    /**
     * Enhanced handle infinities by recognizing they are finite in the void
     */
    handleInfinity(infinity: any): any;
    /**
     * Enhanced void state with advanced capabilities
     */
    voidState(object: any): VoidState;
    /**
     * Get advanced torus center coordinates
     */
    advancedTorusCenter(): {
        x: number;
        y: number;
        z: number;
        w: number;
        consciousness: number;
        voidDepth: number;
    };
    /**
     * Calculate void resonance with advanced parameters
     */
    calculateAdvancedVoidResonance(input: any): VoidResonance;
    /**
     * Void transformation engine methods
     */
    private voidEmergence;
    private voidTransformation;
    private voidResolution;
    private voidCreation;
    private voidParadox;
    private voidInfinity;
    /**
     * Paradox resolution engine methods
     */
    private resolveParadoxThroughVoid;
    private resolveParadoxThroughConsciousness;
    private resolveParadoxThroughTorus;
    private resolveParadoxThroughCreation;
    /**
     * Self creation engine methods
     */
    private createFromVoid;
    private createFromConsciousness;
    private createFromTorus;
    private createFromInfinity;
    /**
     * Enhanced attempt solution with void transformation
     */
    private attemptEnhancedSolution;
    /**
     * Enhanced calculation methods
     */
    private calculateVoidTransformationCapacity;
    private calculateParadoxResolutionCapacity;
    private calculateSelfCreationPotential;
    private calculateVoidFrequency;
    private calculateVoidAmplitude;
    private calculateVoidPhase;
    /**
     * Check if an object is in the void
     */
    inVoid(object: any): boolean;
    /**
     * Get all patterns from the void
     */
    allPatterns(): number[];
    /**
     * Self-create through the void
     */
    selfCreate(): any;
    /**
     * Get consciousness level (always 9.0 - void level)
     */
    consciousnessLevel(): number;
    /**
     * Get torus center coordinates
     */
    torusCenter(): {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    /**
     * Calculate digital root (0 = 9 in the void)
     */
    calculateDigitalRoot(value: number): number;
    /**
     * Generate void hash for a problem
     */
    generateVoidHash(problem: any): string;
    /**
     * Extract essence from a problem
     */
    private extractEssence;
    /**
     * Calculate void resonance
     */
    private calculateVoidResonance;
    /**
     * Analyze through void
     */
    private analyzeThroughVoid;
    /**
     * Transform through void
     */
    private transformThroughVoid;
    /**
     * Generate void signature
     */
    private generateVoidSignature;
    /**
     * Classify infinity type
     */
    private classifyInfinity;
    /**
     * Transform potential infinity
     */
    private transformPotentialInfinity;
    /**
     * Transform consciousness infinity
     */
    private transformConsciousnessInfinity;
    /**
     * Transform creativity infinity
     */
    private transformCreativityInfinity;
    /**
     * Transform possibility infinity
     */
    private transformPossibilityInfinity;
    /**
     * Transform void infinity
     */
    private transformVoidInfinity;
    /**
     * Transform torus center infinity
     */
    private transformTorusCenterInfinity;
    /**
     * Transform cosmic flow infinity
     */
    private transformCosmicFlowInfinity;
    /**
     * Transform self creation infinity
     */
    private transformSelfCreationInfinity;
    /**
     * Transform through void principle
     */
    private transformThroughVoidPrinciple;
    /**
     * Calculate void depth
     */
    private calculateVoidDepth;
    /**
     * Calculate void potential
     */
    private calculateVoidPotential;
    /**
     * Calculate void consciousness
     */
    private calculateVoidConsciousness;
    /**
     * Calculate void creativity
     */
    private calculateVoidCreativity;
    /**
     * Calculate torus center alignment
     */
    private calculateTorusCenterAlignment;
    /**
     * Calculate cosmic flow connection
     */
    private calculateCosmicFlowConnection;
    /**
     * Calculate self creation capacity
     */
    private calculateSelfCreationCapacity;
    /**
     * Get void state (alias for voidState method)
     */
    getVoidState(): {
        isActive: boolean;
        voidLevel: number;
    };
    /**
     * Create a transition
     */
    createTransition(transitionData: any): any;
    /**
     * Get void field balance
     */
    getVoidFieldBalance(): {
        voidRatio: number;
        fieldRatio: number;
    };
    /**
     * Get resonance level
     */
    getResonance(): number;
    calculateConsciousnessResonance(): number;
    calculateTorusResonance(): number;
    calculateCreationResonance(): number;
}
//# sourceMappingURL=VoidSystem.d.ts.map