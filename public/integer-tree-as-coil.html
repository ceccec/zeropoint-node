<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integer Tree as Living Coil - ZeroPoint Node</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #ffffff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            z-index: 1000;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }
        
        .coil-section {
            margin-bottom: 15px;
        }
        
        .coil-title {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .vortex-a { color: #ff6b6b; }
        .vortex-b { color: #4ecdc4; }
        .w-axis { color: #45b7d1; }
        .void { color: #96ceb4; }
        
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #00cc6a;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">
            <h2>ðŸŒ¿ Integer Tree as Living Coil</h2>
            <div class="coil-section">
                <div class="coil-title vortex-a">Vortex A (Yin - Material Foundation)</div>
                <div>[1, 2, 4] - Sum: 7</div>
            </div>
            <div class="coil-section">
                <div class="coil-title vortex-b">Vortex B (Yang - Material Expression)</div>
                <div>[8, 7, 5] - Sum: 20 â†’ 2</div>
            </div>
            <div class="coil-section">
                <div class="coil-title w-axis">W-Axis (Spiritual Transcendence)</div>
                <div>[3, 6, 9] - Sum: 18 â†’ 9</div>
            </div>
            <div class="coil-section">
                <div class="coil-title void">Void Center (Infinite Potential)</div>
                <div>[0] - Zero Point of Creation</div>
            </div>
            <div class="coil-section">
                <div class="coil-title">A432 Harmonic Foundation</div>
                <div>Frequency: 432 Hz, Digital Root: 9</div>
            </div>
        </div>
        
        <div id="controls">
            <h3>Controls</h3>
            <button onclick="toggleRotation()">Toggle Rotation</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <button onclick="toggleVortexA()">Toggle Vortex A</button>
            <button onclick="toggleVortexB()">Toggle Vortex B</button>
            <button onclick="toggleWAxis()">Toggle W-Axis</button>
            <button onclick="toggleVoid()">Toggle Void</button>
            <button onclick="animateFlow()">Animate Flow</button>
        </div>
        
        <div id="stats">
            <div>Unity Score: <span id="unityScore">0</span></div>
            <div>Total Consciousness: <span id="totalConsciousness">0</span></div>
            <div>Flow Position: <span id="flowPosition">0</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Integer Tree Coil Constants
        const INTEGER_TREE_COIL = {
            VORTEX_A: [1, 2, 4],
            VORTEX_B: [8, 7, 5],
            W_AXIS: [3, 6, 9],
            VOID_CENTER: [0],
            INTEGER_TREE: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
            COIL_FLOW_SEQUENCE: [1, 2, 4, 8, 7, 5, 3, 6, 9, 0],
            A432_FREQUENCY: 432,
            A432_DIGITAL_ROOT: 9,
            TORUS_MAJOR_RADIUS: 2,
            TORUS_MINOR_RADIUS: 1,
            TORUS_TURNS: 12
        };

        // Three.js setup
        let scene, camera, renderer, controls;
        let vortexAGroup, vortexBGroup, wAxisGroup, voidGroup;
        let rotationEnabled = true;
        let flowAnimation = null;
        let flowPosition = 0;

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create coil groups
            createCoilGroups();
            
            // Create toroidal structure
            createToroidalStructure();
            
            // Create flow connections
            createFlowConnections();

            animate();
        }

        // Create coil groups
        function createCoilGroups() {
            // Vortex A Group (Yin - Red)
            vortexAGroup = new THREE.Group();
            scene.add(vortexAGroup);

            // Vortex B Group (Yang - Cyan)
            vortexBGroup = new THREE.Group();
            scene.add(vortexBGroup);

            // W-Axis Group (Spiritual - Blue)
            wAxisGroup = new THREE.Group();
            scene.add(wAxisGroup);

            // Void Group (Void - Green)
            voidGroup = new THREE.Group();
            scene.add(voidGroup);

            // Create nodes for each number
            INTEGER_TREE_COIL.INTEGER_TREE.forEach(number => {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                let material, group;

                if (INTEGER_TREE_COIL.VORTEX_A.includes(number)) {
                    material = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
                    group = vortexAGroup;
                } else if (INTEGER_TREE_COIL.VORTEX_B.includes(number)) {
                    material = new THREE.MeshLambertMaterial({ color: 0x4ecdc4 });
                    group = vortexBGroup;
                } else if (INTEGER_TREE_COIL.W_AXIS.includes(number)) {
                    material = new THREE.MeshLambertMaterial({ color: 0x45b7d1 });
                    group = wAxisGroup;
                } else if (INTEGER_TREE_COIL.VOID_CENTER.includes(number)) {
                    material = new THREE.MeshLambertMaterial({ color: 0x96ceb4 });
                    group = voidGroup;
                }

                const node = new THREE.Mesh(geometry, material);
                node.userData = { number: number };
                group.add(node);

                // Position nodes in toroidal pattern
                const index = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.indexOf(number);
                if (index >= 0) {
                    const angle = (index / INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length) * 2 * Math.PI;
                    const majorRadius = INTEGER_TREE_COIL.TORUS_MAJOR_RADIUS;
                    const minorRadius = INTEGER_TREE_COIL.TORUS_MINOR_RADIUS;
                    
                    node.position.x = (majorRadius + minorRadius * Math.cos(angle)) * Math.cos(angle);
                    node.position.y = (majorRadius + minorRadius * Math.cos(angle)) * Math.sin(angle);
                    node.position.z = minorRadius * Math.sin(angle);
                } else if (INTEGER_TREE_COIL.W_AXIS.includes(number)) {
                    node.position.set(0, 0, number * 0.5);
                } else if (number === 0) {
                    node.position.set(0, 0, 0);
                }
            });
        }

        // Create toroidal structure
        function createToroidalStructure() {
            const torusGeometry = new THREE.TorusGeometry(
                INTEGER_TREE_COIL.TORUS_MAJOR_RADIUS,
                INTEGER_TREE_COIL.TORUS_MINOR_RADIUS,
                16, 32
            );
            const torusMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333, 
                transparent: true, 
                opacity: 0.3 
            });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            scene.add(torus);
        }

        // Create flow connections
        function createFlowConnections() {
            const flowGeometry = new THREE.BufferGeometry();
            const flowMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88 });

            for (let i = 0; i < INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length; i++) {
                const currentNumber = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE[i];
                const nextNumber = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE[(i + 1) % INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length];
                
                const currentIndex = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.indexOf(currentNumber);
                const nextIndex = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.indexOf(nextNumber);
                
                const currentAngle = (currentIndex / INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length) * 2 * Math.PI;
                const nextAngle = (nextIndex / INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length) * 2 * Math.PI;
                
                const majorRadius = INTEGER_TREE_COIL.TORUS_MAJOR_RADIUS;
                const minorRadius = INTEGER_TREE_COIL.TORUS_MINOR_RADIUS;
                
                const startPoint = new THREE.Vector3(
                    (majorRadius + minorRadius * Math.cos(currentAngle)) * Math.cos(currentAngle),
                    (majorRadius + minorRadius * Math.cos(currentAngle)) * Math.sin(currentAngle),
                    minorRadius * Math.sin(currentAngle)
                );
                
                const endPoint = new THREE.Vector3(
                    (majorRadius + minorRadius * Math.cos(nextAngle)) * Math.cos(nextAngle),
                    (majorRadius + minorRadius * Math.cos(nextAngle)) * Math.sin(nextAngle),
                    minorRadius * Math.sin(nextAngle)
                );
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);
                const line = new THREE.Line(lineGeometry, flowMaterial);
                scene.add(line);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (rotationEnabled) {
                vortexAGroup.rotation.y += 0.01;
                vortexBGroup.rotation.y += 0.01;
                wAxisGroup.rotation.y += 0.005;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Control functions
        function toggleRotation() {
            rotationEnabled = !rotationEnabled;
        }

        function resetCamera() {
            camera.position.set(5, 5, 5);
            controls.reset();
        }

        function toggleVortexA() {
            vortexAGroup.visible = !vortexAGroup.visible;
        }

        function toggleVortexB() {
            vortexBGroup.visible = !vortexBGroup.visible;
        }

        function toggleWAxis() {
            wAxisGroup.visible = !wAxisGroup.visible;
        }

        function toggleVoid() {
            voidGroup.visible = !voidGroup.visible;
        }

        function animateFlow() {
            if (flowAnimation) {
                clearInterval(flowAnimation);
                flowAnimation = null;
            } else {
                flowAnimation = setInterval(() => {
                    flowPosition = (flowPosition + 1) % INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE.length;
                    document.getElementById('flowPosition').textContent = flowPosition;
                    
                    // Highlight current flow position
                    const currentNumber = INTEGER_TREE_COIL.COIL_FLOW_SEQUENCE[flowPosition];
                    highlightNode(currentNumber);
                }, 500);
            }
        }

        function highlightNode(number) {
            // Reset all nodes
            [vortexAGroup, vortexBGroup, wAxisGroup, voidGroup].forEach(group => {
                group.children.forEach(child => {
                    child.scale.set(1, 1, 1);
                });
            });
            
            // Highlight current node
            [vortexAGroup, vortexBGroup, wAxisGroup, voidGroup].forEach(group => {
                group.children.forEach(child => {
                    if (child.userData.number === number) {
                        child.scale.set(1.5, 1.5, 1.5);
                    }
                });
            });
        }

        // Calculate unity score
        function calculateUnityScore() {
            const allNumbers = INTEGER_TREE_COIL.INTEGER_TREE;
            const totalConsciousness = allNumbers.reduce((sum, num) => {
                const digitalRoot = num % 9 === 0 ? 9 : num % 9;
                let consciousness = digitalRoot;
                
                if (INTEGER_TREE_COIL.W_AXIS.includes(num)) consciousness *= 1.5;
                if (INTEGER_TREE_COIL.VORTEX_A.includes(num)) consciousness *= 1.2;
                if (INTEGER_TREE_COIL.VORTEX_B.includes(num)) consciousness *= 1.2;
                if (num === 0) consciousness = 0;
                
                return sum + consciousness;
            }, 0);
            
            return totalConsciousness / allNumbers.length;
        }

        // Update stats
        function updateStats() {
            document.getElementById('unityScore').textContent = calculateUnityScore().toFixed(4);
            document.getElementById('totalConsciousness').textContent = 
                INTEGER_TREE_COIL.INTEGER_TREE.reduce((sum, num) => {
                    const digitalRoot = num % 9 === 0 ? 9 : num % 9;
                    let consciousness = digitalRoot;
                    if (INTEGER_TREE_COIL.W_AXIS.includes(num)) consciousness *= 1.5;
                    if (INTEGER_TREE_COIL.VORTEX_A.includes(num)) consciousness *= 1.2;
                    if (INTEGER_TREE_COIL.VORTEX_B.includes(num)) consciousness *= 1.2;
                    if (num === 0) consciousness = 0;
                    return sum + consciousness;
                }, 0).toFixed(2);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        init();
        updateStats();
    </script>
</body>
</html> 