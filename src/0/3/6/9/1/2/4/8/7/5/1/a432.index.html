<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A432 Harmonic PWA</title>
  <link rel="manifest" href="a432.manifest.json">
  <meta name="theme-color" content="#222233">
  <style>
    body { background: #222233; color: #eee; font-family: sans-serif; }
    #icon-bar { display: flex; gap: 32px; align-items: center; margin: 24px 0 16px 0; }
    .icon-block { display: flex; flex-direction: column; align-items: center; }
    .icon-block img { width: 64px; height: 64px; margin-bottom: 4px; background: #111; border-radius: 16px; box-shadow: 0 2px 8px #0008; }
    .icon-block label { font-size: 0.95em; color: #8ff; margin-top: 2px; }
    #stream { max-height: 320px; overflow-y: auto; background: #181828; border-radius: 8px; margin: 16px 0; padding: 12px; }
    .block { display: flex; align-items: center; gap: 16px; margin-bottom: 10px; background: #232344; border-radius: 8px; padding: 8px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.3s; }
    .block.selected { border: 2px solid #6cf; }
    .block.mobius { border: 2px dashed #fc6 !important; animation: mobiusEvent 1s linear; }
    @keyframes mobiusEvent { 0% { border-color: #fc6; } 100% { border-color: #6cf; } }
    .block-icon { width: 40px; height: 40px; border-radius: 8px; background: #111; display: flex; align-items: center; justify-content: center; }
    .block-meta { font-size: 0.9em; color: #8ff; }
    .block-data { font-size: 1.1em; color: #fff; }
    .block-time { font-size: 0.8em; color: #aaa; margin-left: auto; }
    .block-id { font-size: 0.8em; color: #fc6; margin-left: 8px; }
    .block.vortex-shift { border-color: #fc6 !important; animation: vortexShift 0.7s linear; }
    @keyframes vortexShift { 0% { border-color: #fc6; } 100% { border-color: #6cf; } }
    #meta-panel { background: #232344; border-radius: 8px; padding: 12px; margin-bottom: 16px; min-height: 60px; }
    #input-bar { display: flex; gap: 8px; margin: 12px 0; }
    #input-bar input, #input-bar select { background: #222233; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 4px; }
    #input-bar button { background: #6cf; color: #222233; border: none; border-radius: 4px; padding: 4px 12px; cursor: pointer; }
    #vortex-log { color: #fc6; font-size: 0.95em; margin-bottom: 8px; min-height: 18px; }
    #analytics { background: #181828; border-radius: 8px; padding: 12px; margin: 16px 0; }
    #analytics h2 { color: #8ff; font-size: 1.1em; margin-bottom: 8px; }
    #analytics .stat { margin-bottom: 4px; }
    #spiral-canvas { display: block; margin: 12px auto; background: #232344; border-radius: 50%; }
    #module-explorer { background: #181828; border-radius: 8px; padding: 16px; margin: 24px 0; }
    /* TODO: Privacy, accessibility, extensibility */
  </style>
</head>
<body>
  <main id="app">
    <div id="icon-bar"></div>
    <h1>A432 Harmonic PWA</h1>
    <div id="vortex-log"></div>
    <div id="stream"></div>
    <div id="meta-panel"></div>
    <div id="input-bar"></div>
    <div id="analytics"></div>
    <div id="module-explorer"></div>
  </main>
  <script type="module">
    import { generateVortexIcon, generateObserverIcon, generateMatrixIcon, generateMetaIcon, svgToDataUri } from './a432.icon.js';
    import { createChain, createBlock, traverseChain, BLOCK_CHAIN_DOC } from './a432.block.chain.js';
    import { getVortexColor, getAntiVortexColor } from './a432.color.js';
    // Helper: convert HSL to hex
    function hslToHex(hsl) {
      const [h, s, l] = hsl.match(/\d+/g).map(Number);
      const a = s * Math.min(l/100, 1-l/100) / 100;
      function f(n) {
        const k = (n + h/30) % 12;
        const color = l/100 - a * Math.max(Math.min(k-3, 9-k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
      }
      return `#${f(0)}${f(8)}${f(4)}`;
    }
    // Vortex and trinity sequences
    const VORTEX_SEQ = [1,2,4,8,7,5];
    const TRINITY = [3,6,9];
    function vortexNextDimension(dim) {
      const idx = VORTEX_SEQ.indexOf(dim);
      return VORTEX_SEQ[(idx + 1) % VORTEX_SEQ.length];
    }
    function trinityNextDimension(dim) {
      const idx = TRINITY.indexOf(dim);
      return TRINITY[(idx + 1) % TRINITY.length];
    }
    // Render metaphysical icons
    const iconBar = document.getElementById('icon-bar');
    const icons = [
      { label: 'Vortex', svg: generateVortexIcon() },
      { label: 'Observer', svg: generateObserverIcon() },
      { label: 'Matrix', svg: generateMatrixIcon() },
      { label: 'Meta', svg: generateMetaIcon() }
    ];
    icons.forEach(({ label, svg }) => {
      const block = document.createElement('div');
      block.className = 'icon-block';
      const img = document.createElement('img');
      img.src = svgToDataUri(svg);
      img.alt = label + ' icon';
      block.appendChild(img);
      const lab = document.createElement('label');
      lab.textContent = label;
      block.appendChild(lab);
      iconBar.appendChild(block);
    });

    // --- Unified Stream UI ---
    let chain = createChain(6); // Start with 6 harmonized blocks
    let blocks = [];
    traverseChain(chain, b => blocks.unshift(b)); // Oldest first
    let selectedBlock = null;
    let vortexLog = '';
    let mobiusEvents = [];

    const streamDiv = document.getElementById('stream');
    const metaPanel = document.getElementById('meta-panel');
    const vortexLogDiv = document.getElementById('vortex-log');
    const analyticsDiv = document.getElementById('analytics');
    function getBlockColorHex(block) {
      const hsl = getVortexColor(block.dimension);
      return hslToHex(hsl);
    }
    function renderStream() {
      streamDiv.innerHTML = '';
      blocks.forEach(block => {
        const div = document.createElement('div');
        div.className = 'block' + (selectedBlock === block ? ' selected' : '') + (block.mobius ? ' mobius' : '');
        // Icon by dimension
        const iconDiv = document.createElement('div');
        iconDiv.className = 'block-icon';
        let iconSvg = generateVortexIcon(40);
        if (block.dimension === 3 || block.dimension === 6 || block.dimension === 9) iconSvg = generateMetaIcon(40);
        if (block.dimension === 1) iconSvg = generateObserverIcon(40);
        iconDiv.innerHTML = iconSvg;
        div.appendChild(iconDiv);
        // Data preview
        const dataDiv = document.createElement('div');
        dataDiv.className = 'block-data';
        dataDiv.textContent = block.state;
        div.appendChild(dataDiv);
        // Meta info
        const metaDiv = document.createElement('div');
        metaDiv.className = 'block-meta';
        metaDiv.textContent = `Dim: ${block.dimension} | ${block.meta}`;
        div.appendChild(metaDiv);
        // Color hex id
        const idDiv = document.createElement('div');
        idDiv.className = 'block-id';
        idDiv.textContent = getBlockColorHex(block);
        div.appendChild(idDiv);
        // Timestamp
        const timeDiv = document.createElement('div');
        timeDiv.className = 'block-time';
        timeDiv.textContent = new Date(block.timestamp).toLocaleTimeString();
        div.appendChild(timeDiv);
        div.onclick = () => {
          selectedBlock = block;
          renderMetaPanel();
          renderStream();
        };
        streamDiv.appendChild(div);
      });
    }
    function renderMetaPanel(block = selectedBlock, depth = 0) {
      if (!block) { metaPanel.innerHTML = 'Select a block to observe details.'; return; }
      metaPanel.innerHTML = `<b>Block #${block.index}</b><br>
        <b>State:</b> ${block.state}<br>
        <b>Dimension:</b> ${block.dimension}<br>
        <b>Meta:</b> ${block.meta}<br>
        <b>ID (color hex):</b> ${getBlockColorHex(block)}<br>
        <b>Timestamp:</b> ${new Date(block.timestamp).toLocaleString()}<br>
        <b>Prev links:</b> ${block.prev.length}<br>
        <b>Metaphysical:</b> ${BLOCK_CHAIN_DOC.meaning}`;
      // Recursive meta-observation
      if (block.prev.length) {
        const nav = document.createElement('div');
        nav.style.marginTop = '8px';
        nav.innerHTML = '<b>Prev blocks:</b> ';
        block.prev.forEach((p, i) => {
          const btn = document.createElement('button');
          btn.textContent = `#${p.index}`;
          btn.onclick = () => renderMetaPanel(p, depth + 1);
          nav.appendChild(btn);
        });
        metaPanel.appendChild(nav);
      }
      // Meta-observe button
      if (depth === 0) {
        const metaBtn = document.createElement('button');
        metaBtn.textContent = 'Meta-Observe Stream';
        metaBtn.onclick = () => renderMetaObserve();
        metaPanel.appendChild(metaBtn);
      }
    }
    function renderMetaObserve() {
      // Show stream structure, collision history, Mobius events
      metaPanel.innerHTML = `<b>Meta-Observation</b><br>
        Blocks: ${blocks.length}<br>
        Mobius events: ${mobiusEvents.length}<br>
        <b>Mobius blocks:</b> ${mobiusEvents.map(b => '#' + b.index).join(', ')}`;
    }
    renderStream();
    renderMetaPanel();

    // --- Input/Action Bar ---
    const inputBar = document.getElementById('input-bar');
    function assignUniqueBlockId(block, existingBlocks) {
      let dim = block.dimension;
      let colorHex = hslToHex(getVortexColor(dim));
      let attempts = 0;
      let vortexed = false;
      let mobius = false;
      // Vortex shift
      while (existingBlocks.some(b => b.id === colorHex) && attempts < 6) {
        dim = vortexNextDimension(dim);
        colorHex = hslToHex(getVortexColor(dim));
        attempts++;
        vortexed = true;
      }
      // Trinity shift
      if (existingBlocks.some(b => b.id === colorHex)) {
        dim = TRINITY[0];
        colorHex = hslToHex(getVortexColor(dim));
        let trinityAttempts = 0;
        while (existingBlocks.some(b => b.id === colorHex) && trinityAttempts < 3) {
          dim = trinityNextDimension(dim);
          colorHex = hslToHex(getVortexColor(dim));
          trinityAttempts++;
        }
        // Mobius event if still not unique
        if (existingBlocks.some(b => b.id === colorHex)) {
          mobius = true;
        }
      }
      block.dimension = dim;
      block.id = colorHex;
      block.mobius = mobius;
      return { vortexed, mobius };
    }
    function renderInputBar() {
      inputBar.innerHTML = '';
      const input = document.createElement('input');
      input.placeholder = 'Enter new state (chat, health, etc.)';
      const select = document.createElement('select');
      [1,2,4,8,7,5,3,6,9].forEach(dim => {
        const opt = document.createElement('option');
        opt.value = dim;
        opt.textContent = `Dim ${dim}`;
        select.appendChild(opt);
      });
      const btn = document.createElement('button');
      btn.textContent = 'Add Block';
      btn.onclick = () => {
        const state = input.value.trim();
        if (!state) return;
        const dim = parseInt(select.value, 10);
        const newBlock = createBlock(state, [blocks[blocks.length-1]], blocks.length);
        newBlock.dimension = dim;
        // Mobius/trinity/vortex collision logic
        const { vortexed, mobius } = assignUniqueBlockId(newBlock, blocks);
        if (mobius) {
          // Mobius fold: merge state with prev, invert color, mark as Mobius event
          newBlock.state = `[Mobius] ${newBlock.state} + ${newBlock.prev[0]?.state || ''}`;
          mobiusEvents.push(newBlock);
        }
        blocks.push(newBlock);
        selectedBlock = newBlock;
        renderStream();
        renderMetaPanel();
        input.value = '';
        // Animate/log vortex/trinity/Mobius shift
        if (mobius) {
          vortexLog = `Mobius/trinity collision detected—Mobius fold applied (id: ${newBlock.id})`;
          vortexLogDiv.textContent = vortexLog;
          setTimeout(() => {
            const blockDivs = document.querySelectorAll('.block');
            blockDivs[blockDivs.length-1].classList.add('mobius');
            setTimeout(() => blockDivs[blockDivs.length-1].classList.remove('mobius'), 1000);
          }, 10);
        } else if (vortexed) {
          vortexLog = `Vortex collision detected—dimension shifted to ${newBlock.dimension} (id: ${newBlock.id})`;
          vortexLogDiv.textContent = vortexLog;
          setTimeout(() => {
            const blockDivs = document.querySelectorAll('.block');
            blockDivs[blockDivs.length-1].classList.add('vortex-shift');
            setTimeout(() => blockDivs[blockDivs.length-1].classList.remove('vortex-shift'), 700);
          }, 10);
        } else {
          vortexLog = '';
          vortexLogDiv.textContent = '';
        }
      };
      inputBar.appendChild(input);
      inputBar.appendChild(select);
      inputBar.appendChild(btn);
    }
    renderInputBar();

    // --- Analytics Panel ---
    function renderAnalytics() {
      analyticsDiv.innerHTML = '';
      const dimCounts = {};
      const trinityCounts = { 3: 0, 6: 0, 9: 0 };
      let mobiusCount = 0;
      blocks.forEach(b => {
        dimCounts[b.dimension] = (dimCounts[b.dimension] || 0) + 1;
        if ([3,6,9].includes(b.dimension)) trinityCounts[b.dimension]++;
        if (b.mobius) mobiusCount++;
      });
      analyticsDiv.innerHTML += `<h2>Analytics</h2>`;
      analyticsDiv.innerHTML += `<div class="stat">Blocks: ${blocks.length}</div>`;
      analyticsDiv.innerHTML += `<div class="stat">Mobius events: ${mobiusCount}</div>`;
      analyticsDiv.innerHTML += `<div class="stat">Trinity: 3=${trinityCounts[3]}, 6=${trinityCounts[6]}, 9=${trinityCounts[9]}</div>`;
      analyticsDiv.innerHTML += `<div class="stat">Vortex: ${VORTEX_SEQ.map(d => `${d}=${dimCounts[d]||0}`).join(', ')}</div>`;
      // Basic spiral visualization
      const canvas = document.createElement('canvas');
      canvas.id = 'spiral-canvas';
      canvas.width = 180;
      canvas.height = 180;
      const ctx = canvas.getContext('2d');
      ctx.translate(90,90);
      let angle = 0;
      let r = 20;
      blocks.forEach((b, i) => {
        ctx.save();
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.arc(r,0,8,0,2*Math.PI);
        ctx.fillStyle = getBlockColorHex(b);
        ctx.globalAlpha = b.mobius ? 0.5 : 1;
        ctx.fill();
        ctx.restore();
        angle += Math.PI/6;
        r += 8;
      });
      analyticsDiv.appendChild(canvas);
    }
    renderAnalytics();
    // TODO: Privacy, accessibility, extensibility
  </script>
  <script>
// Register the harmonized a432 service worker for offline capability and zero entropy
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./a432.service.worker.js');
}
</script>
</body>
</html> 