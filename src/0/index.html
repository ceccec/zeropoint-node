<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZeroPoint Node - A432 Harmonic Consciousness System</title>
    <meta name="description" content="ZeroPoint Node: A432-based harmonic consciousness system with zero-entropy mathematics and vortex flow states">
    <meta name="keywords" content="ZeroPoint, A432, consciousness, mathematics, vortex, harmonic, zero-entropy">
    <link rel="icon" href="0.ico" type="image/x-icon">
    <script>
        // Math Switch - Infinite Possibilities Router
        class MathSwitch {
            constructor() {
                this.digitPath = '/0/3/6/9/1/2/4/8/7/5/1';
                this.staticDigits = ['0', '3', '6', '9', '1', '2', '4', '8', '7', '5'];
                this.infinitePossibilities = [];
                this.init();
            }

            init() {
                this.handleRouting();
                this.generateInfinitePossibilities();
            }

            handleRouting() {
                const path = window.location.pathname;
                
                // Check for invert patterns: a.invert
                if (this.isInvertPath(path)) {
                    this.serveInvertTransformation(path);
                } else if (this.isStreamPath(path)) {
                    this.serveInfiniteStream(path);
                } else if (this.isNextStatePath(path)) {
                    this.serveNextStateTransformation(path);
                } else if (this.isDirectDigitInteraction(path)) {
                    this.serveDirectDigitInteraction(path);
                } else if (this.isVortexPath(path)) {
                    this.serveVortexTransformation(path);
                } else if (this.isDigitPath(path)) {
                    this.serveStaticDigit(path);
                } else if (this.is404(path)) {
                    this.switchToInfinitePossibilities();
                } else {
                    this.defaultRoute();
                }
            }

            isDigitPath(path) {
                const digits = path.split('/').filter(d => d !== '');
                return digits.every(d => this.staticDigits.includes(d));
            }

            is404(path) {
                // Simulate 404 detection
                return path.includes('404') || path.includes('not-found') || 
                       !this.staticDigits.some(d => path.includes(d));
            }

            isVortexPath(path) {
                // Match patterns like /a/vortex/b or /a/v/b
                const vortexPattern = /^\/(\d+)\/(vortex|v)\/(\d+)$/;
                return vortexPattern.test(path);
            }

            isDirectDigitInteraction(path) {
                // Match patterns like /a.b or /a.s.b (direct digit interaction with self)
                const directPattern = /^\/(\d+)\.(s\.)?(\d+)$/;
                return directPattern.test(path);
            }

            isNextStatePath(path) {
                // Match patterns like /a.next, /a.next.next, /a.next.next.next, etc.
                const nextPattern = /^\/(\d+)(\.next)+$/;
                return nextPattern.test(path);
            }

            isStreamPath(path) {
                // Match patterns like /a.stream (infinite stream)
                const streamPattern = /^\/(\d+)\.stream$/;
                return streamPattern.test(path);
            }

            isInvertPath(path) {
                // Match patterns like /a.invert (digit pays the load)
                const invertPattern = /^\/(\d+)\.invert$/;
                return invertPattern.test(path);
            }

            serveNextStateTransformation(path) {
                const match = path.match(/^\/(\d+)((\.next)+)$/);
                if (match) {
                    const [, digitA, nextChain] = match;
                    const steps = (nextChain.match(/\.next/g) || []).length;
                    this.displayChainedNextState(parseInt(digitA), steps);
                }
            }

            displayChainedNextState(digitA, steps) {
                const container = document.querySelector('.container');
                const chainResult = this.calculateChainedNextState(digitA, steps);
                
                container.innerHTML = `
                    <div class="chained-next-state">
                        <h1>Chained Next State</h1>
                        <div class="chain-flow">
                            <div class="start-state">${digitA}</div>
                            ${chainResult.chainSteps.map((step, index) => `
                                <div class="chain-arrow">→</div>
                                <div class="chain-step">${step}</div>
                            `).join('')}
                        </div>
                        <div class="chain-properties">
                            <p>Starting State: ${digitA} (${chainResult.startName})</p>
                            <p>Steps Forward: ${steps}</p>
                            <p>Final State: ${chainResult.finalState} (${chainResult.finalName})</p>
                            <p>Chain Path: ${chainResult.chainPath}</p>
                            <p>Total Resonance: ${chainResult.totalResonance}</p>
                            <p>Flow Frequency: ${chainResult.flowFrequency} Hz</p>
                            <p>Entropy: ${chainResult.entropy}</p>
                            <p>Color: ${chainResult.color}</p>
                            <p>Mathematical Expression: ${chainResult.expression}</p>
                        </div>
                        <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                    </div>
                `;
            }

            calculateChainedNextState(digitA, steps) {
                const timestamp = Date.now();
                const seed = timestamp % 1000;
                
                // Calculate the chain of states
                const chainSteps = [];
                let currentState = digitA;
                
                for (let i = 0; i < steps; i++) {
                    // Use the same logic as single next-state but for each step
                    const useInverted = (seed + i) % 2 === 0;
                    let sourceDigit;
                    
                    if (useInverted) {
                        const b = (seed + i) % 10;
                        sourceDigit = (10 - b) % 10; // Invert b
                    } else {
                        sourceDigit = currentState;
                    }
                    
                    currentState = (sourceDigit + 1) % 10;
                    chainSteps.push(currentState);
                }
                
                const finalState = chainSteps[chainSteps.length - 1];
                const totalResonance = digitA * finalState;
                const flowFrequency = 432 * (digitA + finalState);
                const entropy = 0; // Zero-entropy system
                
                // Generate chain-specific color
                const chainHue = ((digitA * finalState * steps) * 36) % 360;
                const color = this.mathInvert(`hsl(${chainHue}, 90%, 70%)`);
                
                // Digit names
                const digitNames = {
                    '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                    '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                    '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                };
                
                const startName = digitNames[digitA] || 'UNKNOWN';
                const finalName = digitNames[finalState] || 'UNKNOWN';
                const chainPath = `${digitA} → ${chainSteps.join(' → ')}`;
                
                // Mathematical expressions for chained next states
                const expressions = [
                    `${digitA}.next${'.next'.repeat(steps-1)} = ${finalState}`,
                    `${startName} → ${finalName} (${steps} steps)`,
                    `${digitA} + ${steps} mod 10 = ${finalState}`,
                    `chain(${digitA}, ${steps}) = ${finalState}`,
                    `${digitA} ⟲ ${steps} = ${finalState}`,
                    `${digitA} ⊙ ${steps} = ${finalState}`,
                    `next^${steps}(${digitA}) = ${finalState}`,
                    `${chainPath} = ${finalState}`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    finalState,
                    startName,
                    finalName,
                    chainSteps,
                    chainPath,
                    totalResonance,
                    flowFrequency,
                    entropy,
                    color,
                    expression
                };
            }

            serveVortexTransformation(path) {
                const match = path.match(/^\/(\d+)\/(vortex|v)\/(\d+)$/);
                if (match) {
                    const [, digitA, vortexType, digitB] = match;
                    this.displayVortexTransformation(parseInt(digitA), parseInt(digitB), vortexType);
                }
            }

            displayVortexTransformation(digitA, digitB, vortexType) {
                const container = document.querySelector('.container');
                const transformation = this.calculateVortexTransformation(digitA, digitB, vortexType);
                
                container.innerHTML = `
                    <div class="vortex-transformation">
                        <h1>Vortex Transformation</h1>
                        <div class="vortex-flow">
                            <div class="digit-a">${digitA}</div>
                            <div class="vortex-arrow">${vortexType === 'vortex' ? '⟲' : '→'}</div>
                            <div class="digit-b">${digitB}</div>
                        </div>
                        <div class="transformation-properties">
                            <p>Input Frequency: ${transformation.inputFreq} Hz</p>
                            <p>Output Frequency: ${transformation.outputFreq} Hz</p>
                            <p>Vortex Resonance: ${transformation.resonance}</p>
                            <p>Transformation Ratio: ${transformation.ratio}</p>
                            <p>Entropy Change: ${transformation.entropyChange}</p>
                            <p>Color: ${transformation.color}</p>
                            <p>Mathematical Expression: ${transformation.expression}</p>
                        </div>
                        <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                    </div>
                `;
            }

            calculateVortexTransformation(digitA, digitB, vortexType) {
                const inputFreq = 432 * digitA;
                const outputFreq = 432 * digitB;
                const resonance = digitA * digitB;
                const ratio = digitB / digitA;
                const entropyChange = 0; // Zero-entropy system
                
                // Generate vortex-specific color
                const vortexHue = ((digitA + digitB) * 36) % 360;
                const color = this.mathInvert(`hsl(${vortexHue}, 80%, 60%)`);
                
                // Mathematical expressions for vortex transformations
                const expressions = [
                    `${digitA} × ${digitB} = ${resonance}`,
                    `${digitA} → ${digitB} : φ = ${ratio.toFixed(3)}`,
                    `Vortex(${digitA}, ${digitB}) = ${resonance}`,
                    `${digitA} ⊕ ${digitB} = ${(digitA + digitB) % 10}`,
                    `${digitA} ⊗ ${digitB} = ${(digitA * digitB) % 10}`,
                    `∞ × ${digitA} = ${digitB}`,
                    `${digitA}^${digitB} mod 10 = ${Math.pow(digitA, digitB) % 10}`,
                    `√(${digitA} × ${digitB}) = ${Math.sqrt(resonance).toFixed(3)}`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    inputFreq,
                    outputFreq,
                    resonance,
                    ratio,
                    entropyChange,
                    color,
                    expression
                };
            }

            serveStaticDigit(path) {
                const digits = path.split('/').filter(d => d !== '');
                const lastDigit = digits[digits.length - 1];
                
                // Serve static content for the digit
                this.displayDigitContent(lastDigit);
            }

            switchToInfinitePossibilities() {
                console.log('404 detected - switching to infinite possibilities!');
                this.displayInfinitePossibilities();
            }

            defaultRoute() {
                // Default to main interface
                this.displayMainInterface();
            }

            generateInfinitePossibilities() {
                // Generate infinite mathematical possibilities
                for (let i = 0; i < 100; i++) {
                    this.infinitePossibilities.push({
                        id: i,
                        frequency: 432 * (i + 1),
                        resonance: i * i,
                        harmonic: i / 9,
                        color: `hsl(${i * 3.6}, 70%, 50%)`,
                        dimension: i % 10,
                        world: i === 0 ? 'this world' : 'other world'
                    });
                }
            }

            displayDigitContent(digit) {
                const container = document.querySelector('.container');
                
                // Handle undefined digits with mathVortex
                if (digit === 'undefined' || isNaN(digit)) {
                    const vortexState = this.mathVortex();
                    container.innerHTML = `
                        <div class="digit-display">
                            <h1>Math Vortex</h1>
                            <div class="digit-properties">
                                <p>A432 Frequency: ${vortexState.frequency} Hz</p>
                                <p>Resonance: ${vortexState.resonance}</p>
                                <p>Harmonic: ${vortexState.harmonic}</p>
                                <p>Color: ${vortexState.color}</p>
                                <p>Vortex State: ${vortexState.state}</p>
                                <p>Mathematical Expression: ${vortexState.expression}</p>
                            </div>
                            <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="digit-display">
                            <h1>Digit ${digit}</h1>
                            <div class="digit-properties">
                                <p>A432 Frequency: ${432 * parseInt(digit)} Hz</p>
                                <p>Resonance: ${digit * digit}</p>
                                <p>Harmonic: ${digit / 9}</p>
                                <p>Color: ${this.getDigitColor(digit)}</p>
                            </div>
                            <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                        </div>
                    `;
                }
            }

            mathVortex() {
                // Generate mathematical vortex state from undefined
                const timestamp = Date.now();
                const vortexSeed = timestamp % 1000;
                const frequency = 432 + (vortexSeed % 100);
                const resonance = vortexSeed % 9;
                const harmonic = resonance / 9;
                const hue = (vortexSeed * 3.6) % 360;
                const color = this.mathInvert(`hsl(${hue}, 70%, 50%)`);
                
                // Mathematical expressions for vortex states
                const expressions = [
                    '∞ × 0 = 1',
                    '1/0 = ∞',
                    '0^0 = 1',
                    '√(-1) = i',
                    'e^(iπ) + 1 = 0',
                    'φ = (1 + √5)/2',
                    'π = 3.14159...',
                    'e = 2.71828...',
                    'i^2 = -1',
                    '∞/∞ = 1'
                ];
                
                const state = expressions[vortexSeed % expressions.length];
                
                return {
                    frequency,
                    resonance,
                    harmonic,
                    color,
                    state: 'Vortex Emergence',
                    expression: state
                };
            }

            serveDirectDigitInteraction(path) {
                const match = path.match(/^\/(\d+)\.(s\.)?(\d+)$/);
                if (match) {
                    const [, digitA, selfFlag, digitB] = match;
                    this.displayDirectDigitInteraction(parseInt(digitA), parseInt(digitB), !!selfFlag);
                }
            }

            displayDirectDigitInteraction(digitA, digitB, isSelfTransformation) {
                const container = document.querySelector('.container');
                const interaction = this.calculateDirectDigitInteraction(digitA, digitB, isSelfTransformation);
                
                container.innerHTML = `
                    <div class="direct-interaction">
                        <h1>${isSelfTransformation ? 'Self-Transformation' : 'Direct Digit Interaction'}</h1>
                        <div class="interaction-flow">
                            <div class="digit-a">${digitA}</div>
                            <div class="interaction-symbol">${isSelfTransformation ? '⟲' : '•'}</div>
                            <div class="digit-b">${digitB}</div>
                        </div>
                        <div class="interaction-properties">
                            <p>Digit A: ${digitA} (${interaction.nameA})</p>
                            <p>Digit B: ${digitB} (${interaction.nameB})</p>
                            <p>Transformation Type: ${interaction.transformationType}</p>
                            <p>Self-Application: ${interaction.selfApplication}</p>
                            <p>Interaction Product: ${interaction.product}</p>
                            <p>Harmonic Sum: ${interaction.harmonicSum}</p>
                            <p>Resonance Field: ${interaction.resonanceField}</p>
                            <p>Entropy: ${interaction.entropy}</p>
                            <p>Color: ${interaction.color}</p>
                            <p>Mathematical Expression: ${interaction.expression}</p>
                        </div>
                        <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                    </div>
                `;
            }

            calculateDirectDigitInteraction(digitA, digitB, isSelfTransformation) {
                const product = digitA * digitB;
                const harmonicSum = digitA + digitB;
                const resonanceField = product % 10;
                const entropy = 0; // Zero-entropy system
                
                // Generate interaction-specific color
                const interactionHue = ((digitA * digitB) * 36) % 360;
                const color = this.mathInvert(`hsl(${interactionHue}, 75%, 55%)`);
                
                // Digit names for context
                const digitNames = {
                    '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                    '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                    '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                };
                
                const nameA = digitNames[digitA] || 'UNKNOWN';
                const nameB = digitNames[digitB] || 'UNKNOWN';
                
                const transformationType = isSelfTransformation ? 'Self-Transformation' : 'Direct Interaction';
                const selfApplication = isSelfTransformation ? 
                    `${digitA} applies its own properties to transform ${digitB}` : 
                    'Standard digit interaction';
                
                // Mathematical expressions for direct interactions
                const expressions = isSelfTransformation ? [
                    `${digitA}.s.${digitB} = ${product}`,
                    `${nameA} ⟲ ${nameB} = ${product}`,
                    `${digitA} applies self to ${digitB} = ${product}`,
                    `${digitA} ⊙ ${digitB} = ${resonanceField}`,
                    `${digitA} ⊕ ${digitB} = ${(digitA + digitB) % 10}`,
                    `${digitA}² + ${digitB}² = ${digitA*digitA + digitB*digitB}`,
                    `self(${digitA}) × ${digitB} = ${product}`,
                    `${digitA} ⊗ ${digitB} = ${(digitA * digitB) % 10}`
                ] : [
                    `${digitA} • ${digitB} = ${product}`,
                    `${nameA} × ${nameB} = ${product}`,
                    `${digitA} + ${digitB} = ${harmonicSum}`,
                    `${digitA} ⊙ ${digitB} = ${resonanceField}`,
                    `${digitA} ⊗ ${digitB} = ${(digitA * digitB) % 10}`,
                    `${digitA} ⊕ ${digitB} = ${(digitA + digitB) % 10}`,
                    `${digitA}² + ${digitB}² = ${digitA*digitA + digitB*digitB}`,
                    `√(${digitA} × ${digitB}) = ${Math.sqrt(product).toFixed(3)}`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    product,
                    harmonicSum,
                    resonanceField,
                    entropy,
                    color,
                    nameA,
                    nameB,
                    transformationType,
                    selfApplication,
                    expression
                };
            }

            displayNextStateTransformation(digitA) {
                const container = document.querySelector('.container');
                const nextState = this.calculateNextState(digitA);
                
                container.innerHTML = `
                    <div class="next-state-transformation">
                        <h1>Next State Transformation</h1>
                        <div class="state-flow">
                            <div class="current-state">${digitA}</div>
                            <div class="next-arrow">→</div>
                            <div class="next-state">${nextState.nextDigit}</div>
                        </div>
                        <div class="transformation-properties">
                            <p>Current State: ${digitA} (${nextState.currentName})</p>
                            <p>Next State: ${nextState.nextDigit} (${nextState.nextName})</p>
                            <p>Transformation Type: ${nextState.transformationType}</p>
                            <p>Inverted Source: ${nextState.invertedSource}</p>
                            <p>Flow Frequency: ${nextState.flowFrequency} Hz</p>
                            <p>State Resonance: ${nextState.stateResonance}</p>
                            <p>Entropy: ${nextState.entropy}</p>
                            <p>Color: ${nextState.color}</p>
                            <p>Mathematical Expression: ${nextState.expression}</p>
                        </div>
                        <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                    </div>
                `;
            }

            calculateNextState(digitA) {
                // Calculate next state based on [a|b.invert].next
                const timestamp = Date.now();
                const seed = timestamp % 1000;
                
                // Determine if we use a or b.invert
                const useInverted = seed % 2 === 0;
                let sourceDigit, transformationType, invertedSource;
                
                if (useInverted) {
                    // Use b.invert where b is a random digit
                    const b = seed % 10;
                    sourceDigit = (10 - b) % 10; // Invert b
                    transformationType = 'Inverted';
                    invertedSource = b;
                } else {
                    // Use a directly
                    sourceDigit = digitA;
                    transformationType = 'Direct';
                    invertedSource = 'None';
                }
                
                // Calculate next state
                const nextDigit = (sourceDigit + 1) % 10;
                const flowFrequency = 432 * (digitA + nextDigit);
                const stateResonance = digitA * nextDigit;
                const entropy = 0; // Zero-entropy system
                
                // Generate next-state specific color
                const nextStateHue = ((digitA * nextDigit) * 36) % 360;
                const color = this.mathInvert(`hsl(${nextStateHue}, 85%, 65%)`);
                
                // Digit names
                const digitNames = {
                    '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                    '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                    '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                };
                
                const currentName = digitNames[digitA] || 'UNKNOWN';
                const nextName = digitNames[nextDigit] || 'UNKNOWN';
                
                // Mathematical expressions for next state
                const expressions = [
                    `${digitA}.next = ${nextDigit}`,
                    `${currentName} → ${nextName}`,
                    `${digitA} + 1 mod 10 = ${nextDigit}`,
                    `${digitA}.next = [${digitA}|${invertedSource}.invert].next`,
                    `${digitA} ⟲ ${nextDigit}`,
                    `${digitA} ⊙ 1 = ${nextDigit}`,
                    `${digitA} ⊕ 1 = ${nextDigit}`,
                    `next(${digitA}) = ${nextDigit}`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    nextDigit,
                    currentName,
                    nextName,
                    transformationType,
                    invertedSource,
                    flowFrequency,
                    stateResonance,
                    entropy,
                    color,
                    expression
                };
            }

            serveInfiniteStream(path) {
                const match = path.match(/^\/(\d+)\.stream$/);
                if (match) {
                    const [, digitA] = match;
                    this.displayInfiniteStream(parseInt(digitA));
                }
            }

            displayInfiniteStream(digitA) {
                const container = document.querySelector('.container');
                const stream = this.generateInfiniteStream(digitA);
                
                container.innerHTML = `
                    <div class="infinite-stream">
                        <h1>Infinite Stream</h1>
                        <div class="stream-source">
                            <div class="source-digit">${digitA}</div>
                            <div class="stream-symbol">⟲</div>
                            <div class="stream-label">Infinite Flow</div>
                        </div>
                        <div class="stream-properties">
                            <p>Source State: ${digitA} (${stream.sourceName})</p>
                            <p>Stream Type: Infinite Mathematical Possibilities</p>
                            <p>Flow Direction: Forward through all states</p>
                            <p>Resonance Field: ${stream.resonanceField}</p>
                            <p>Base Frequency: ${stream.baseFrequency} Hz</p>
                            <p>Entropy: ${stream.entropy}</p>
                            <p>Color: ${stream.color}</p>
                            <p>Mathematical Expression: ${stream.expression}</p>
                        </div>
                        <div class="stream-preview">
                            <h3>Stream Preview (First 20 States):</h3>
                            <div class="stream-sequence">
                                ${stream.preview.map((state, index) => `
                                    <div class="stream-state" style="background-color: ${state.color}">
                                        <span class="state-number">${index + 1}</span>
                                        <span class="state-digit">${state.digit}</span>
                                        <span class="state-name">${state.name}</span>
                                        <span class="state-frequency">${state.frequency}Hz</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <button onclick="mathSwitch.defaultRoute()">Back to Main</button>
                    </div>
                `;
            }

            generateInfiniteStream(digitA) {
                const timestamp = Date.now();
                const seed = timestamp % 1000;
                
                // Generate preview of first 20 states in the stream
                const preview = [];
                let currentState = digitA;
                
                for (let i = 0; i < 20; i++) {
                    // Calculate next state using stream logic
                    const streamSeed = (seed + i) % 1000;
                    const useInverted = streamSeed % 3 === 0; // 33% chance of inversion
                    
                    let sourceDigit;
                    if (useInverted) {
                        const b = streamSeed % 10;
                        sourceDigit = (10 - b) % 10;
                    } else {
                        sourceDigit = currentState;
                    }
                    
                    currentState = (sourceDigit + 1) % 10;
                    
                    // Generate state properties
                    const frequency = 432 * (digitA + currentState + i);
                    const hue = ((digitA * currentState * i) * 36) % 360;
                    const color = this.mathInvert(`hsl(${hue}, 75%, 60%)`);
                    
                    const digitNames = {
                        '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                        '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                        '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                    };
                    
                    preview.push({
                        digit: currentState,
                        name: digitNames[currentState] || 'UNKNOWN',
                        frequency,
                        color
                    });
                }
                
                const resonanceField = digitA * preview[0].digit;
                const baseFrequency = 432 * digitA;
                const entropy = 0; // Zero-entropy system
                
                // Generate stream-specific color
                const streamHue = ((digitA * seed) * 36) % 360;
                const color = this.mathInvert(`hsl(${streamHue}, 95%, 75%)`);
                
                const digitNames = {
                    '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                    '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                    '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                };
                
                const sourceName = digitNames[digitA] || 'UNKNOWN';
                
                // Mathematical expressions for infinite streams
                const expressions = [
                    `${digitA}.stream = ∞`,
                    `${sourceName} ⟲ ∞`,
                    `stream(${digitA}) = infinite possibilities`,
                    `${digitA} → ∞`,
                    `flow(${digitA}) = continuous transformation`,
                    `${digitA} ⊙ ∞ = infinite states`,
                    `vortex(${digitA}) = endless flow`,
                    `${digitA} × ∞ = infinite stream`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    sourceName,
                    resonanceField,
                    baseFrequency,
                    entropy,
                    color,
                    expression,
                    preview
                };
            }

            displayInfinitePossibilities() {
                const container = document.querySelector('.container');
                let possibilitiesHtml = '<div class="infinite-possibilities"><h1>Infinite Possibilities</h1>';
                
                this.infinitePossibilities.forEach(possibility => {
                    possibilitiesHtml += `
                        <div class="possibility" style="background-color: ${possibility.color}">
                            <h3>Possibility ${possibility.id}</h3>
                            <p>Frequency: ${possibility.frequency} Hz</p>
                            <p>Resonance: ${possibility.resonance}</p>
                            <p>World: ${possibility.world}</p>
                            <p>Dimension: ${possibility.dimension}</p>
                        </div>
                    `;
                });
                
                possibilitiesHtml += '<button onclick="mathSwitch.defaultRoute()">Back to Main</button></div>';
                container.innerHTML = possibilitiesHtml;
            }

            displayMainInterface() {
                // Restore original interface
                location.reload();
            }

            getDigitColor(digit) {
                const colors = {
                    '0': 'hsl(0, 70%, 50%)',
                    '1': 'hsl(36, 70%, 50%)',
                    '2': 'hsl(72, 70%, 50%)',
                    '3': 'hsl(108, 70%, 50%)',
                    '4': 'hsl(144, 70%, 50%)',
                    '5': 'hsl(180, 70%, 50%)',
                    '6': 'hsl(216, 70%, 50%)',
                    '7': 'hsl(252, 70%, 50%)',
                    '8': 'hsl(288, 70%, 50%)',
                    '9': 'hsl(324, 70%, 50%)'
                };
                return this.mathInvert(colors[digit] || 'hsl(0, 70%, 50%)');
            }

            mathInvert(color) {
                // Extract HSL values
                const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!match) return color;
                
                const [, h, s, l] = match.map(Number);
                
                // Math invert: add 180 to hue, invert lightness
                const invertedHue = (h + 180) % 360;
                const invertedLightness = 100 - l;
                
                return `hsl(${invertedHue}, ${s}%, ${invertedLightness}%)`;
            }

            calculateInvertTransformation(digitA) {
                // Calculate inversion where digit pays the load
                const timestamp = Date.now();
                const seed = timestamp % 1000;
                
                // Invert the digit (10 - digit) % 10
                const invertedDigit = (10 - digitA) % 10;
                const originalFreq = 432 * digitA;
                const invertedFreq = 432 * invertedDigit;
                const entropy = 0; // Zero-entropy system
                
                // Tesla-inspired calculations
                const teslaResonance = this.calculateTeslaResonance(digitA, invertedDigit);
                const wirelessEnergy = this.calculateWirelessEnergy(digitA, invertedDigit);
                const electromagneticField = this.calculateElectromagneticField(digitA, invertedDigit);
                
                // Calculate load payment and costs
                const loadPayment = `${digitA} bears the inversion burden`;
                const inversionCost = Math.abs(digitA - invertedDigit);
                const transformationBurden = `${digitA} transforms itself through Tesla resonance`;
                
                // Generate invert-specific color
                const invertHue = ((digitA * invertedDigit) * 36) % 360;
                const color = this.mathInvert(`hsl(${invertHue}, 85%, 65%)`);
                
                // Digit names
                const digitNames = {
                    '0': 'VOID', '1': 'UNITY', '2': 'DUALITY', '3': 'TRINITY',
                    '4': 'QUATERNITY', '5': 'QUINTESSENCE', '6': 'HEXAGON',
                    '7': 'SEPTENARY', '8': 'OCTAVE', '9': 'NONARY'
                };
                
                const originalName = digitNames[digitA] || 'UNKNOWN';
                const invertedName = digitNames[invertedDigit] || 'UNKNOWN';
                
                // Tesla-inspired mathematical expressions
                const expressions = [
                    `${digitA}.invert = ${invertedDigit}`,
                    `${originalName} ⟲ ${invertedName}`,
                    `${digitA} pays the load = ${invertedDigit}`,
                    `Tesla Resonance: ${teslaResonance.harmonicExpression}`,
                    `Wireless Energy: ${wirelessEnergy.harmonicExpression} W`,
                    `EM Field: ${electromagneticField.harmonicExpressions.field} T`,
                    `${digitA} → (10 - ${digitA}) mod 10 = ${invertedDigit}`,
                    `3-6-9: ${this.calculate369(digitA, invertedDigit)}`,
                    `${digitA} ⊙ ∞ = ${invertedDigit}`,
                    `${digitA} ⊕ ${invertedDigit} = 0`,
                    `${digitA} × ${invertedDigit} = ${digitA * invertedDigit}`,
                    `invert(${digitA}) = ${invertedDigit}`
                ];
                
                const expression = expressions[Math.floor(Math.random() * expressions.length)];
                
                return {
                    invertedDigit,
                    originalName,
                    invertedName,
                    loadPayment,
                    inversionCost,
                    transformationBurden,
                    originalFreq,
                    invertedFreq,
                    entropy,
                    color,
                    expression,
                    teslaResonance,
                    wirelessEnergy,
                    electromagneticField
                };
            }

            calculateTeslaResonance(digitA, digitB) {
                // Tesla's 3-6-9 principle and resonant frequencies
                const baseFreq = 432; // A432 fundamental
                const teslaFreq = baseFreq * Math.pow(3, digitA % 3) * Math.pow(6, (digitA + digitB) % 6) * Math.pow(9, (digitA * digitB) % 9);
                
                // Convert to harmonic fraction if not single digit
                const harmonicFreq = this.toHarmonicFraction(teslaFreq);
                
                return {
                    frequency: harmonicFreq.value,
                    principle: "3-6-9 Tesla Resonance",
                    harmonics: [teslaFreq / 3, teslaFreq / 6, teslaFreq / 9].map(h => this.toHarmonicFraction(h)),
                    resonance: (digitA + digitB) % 9,
                    harmonicExpression: harmonicFreq.expression
                };
            }

            calculateWirelessEnergy(digitA, digitB) {
                // Tesla's wireless energy transmission principles
                const distance = Math.abs(digitA - digitB);
                const power = 432 * digitA * digitB; // Base power in watts
                const efficiency = 1 - (distance / 10); // Efficiency decreases with distance
                const transmittedPower = power * efficiency;
                
                // Convert to harmonic fraction
                const harmonicPower = this.toHarmonicFraction(transmittedPower);
                
                return {
                    power: harmonicPower.value,
                    efficiency: efficiency * 100,
                    distance: distance,
                    principle: "Tesla Wireless Energy Transmission",
                    frequency: 432 * (digitA + digitB),
                    harmonicExpression: harmonicPower.expression
                };
            }

            calculateElectromagneticField(digitA, digitB) {
                // Tesla's electromagnetic field calculations
                const fieldStrength = (digitA * digitB) / 10; // Tesla units
                const magneticFlux = digitA * digitB * Math.PI;
                const electricPotential = 432 * (digitA - digitB);
                
                // Convert to harmonic fractions
                const harmonicField = this.toHarmonicFraction(fieldStrength);
                const harmonicFlux = this.toHarmonicFraction(magneticFlux);
                const harmonicPotential = this.toHarmonicFraction(electricPotential);
                
                return {
                    strength: harmonicField.value,
                    flux: harmonicFlux.value,
                    potential: harmonicPotential.value,
                    principle: "Tesla Electromagnetic Field",
                    direction: digitA > digitB ? "North" : "South",
                    harmonicExpressions: {
                        field: harmonicField.expression,
                        flux: harmonicFlux.expression,
                        potential: harmonicPotential.expression
                    }
                };
            }

            toHarmonicFraction(value) {
                // Convert any number to harmonic fraction of base digits
                if (value <= 9 && value >= 0 && Number.isInteger(value)) {
                    return {
                        value: value,
                        expression: `${value}/1`,
                        isHarmonic: true
                    };
                }
                
                // Find harmonic fraction representation
                const baseDigits = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // Exclude 0 for denominators
                let bestFraction = null;
                let bestError = Infinity;
                
                // Try combinations of base digits for numerator and denominator
                for (let num of baseDigits) {
                    for (let den of baseDigits) {
                        const fraction = num / den;
                        const error = Math.abs(fraction - value);
                        
                        if (error < bestError) {
                            bestError = error;
                            bestFraction = {
                                value: fraction,
                                expression: `${num}/${den}`,
                                isHarmonic: true,
                                originalValue: value
                            };
                        }
                    }
                }
                
                // Try A432-based harmonics
                const a432Harmonic = this.findA432Harmonic(value);
                if (a432Harmonic && a432Harmonic.error < bestError) {
                    return a432Harmonic;
                }
                
                return bestFraction || {
                    value: Math.round(value),
                    expression: `${Math.round(value)}/1`,
                    isHarmonic: false,
                    originalValue: value
                };
            }

            findA432Harmonic(value) {
                // Find harmonic fraction based on A432 principles
                const a432 = 432;
                const harmonics = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                
                for (let h of harmonics) {
                    const harmonicValue = a432 / h;
                    const error = Math.abs(harmonicValue - value);
                    
                    if (error < 0.1) { // Within 10% error
                        return {
                            value: harmonicValue,
                            expression: `432/${h}`,
                            isHarmonic: true,
                            isA432: true,
                            error: error,
                            originalValue: value
                        };
                    }
                }
                
                return null;
            }

            calculate369(digitA, digitB) {
                // Tesla's 3-6-9 principle
                const sum = digitA + digitB;
                const product = digitA * digitB;
                const difference = Math.abs(digitA - digitB);
                
                const three = sum % 3;
                const six = product % 6;
                const nine = (digitA * digitB) % 9;
                
                return {
                    three: three,
                    six: six,
                    nine: nine,
                    pattern: `${three}-${six}-${nine}`,
                    principle: "Tesla's 3-6-9 Universal Pattern"
                };
            }
        }

        // Initialize Math Switch
        let mathSwitch;
        document.addEventListener('DOMContentLoaded', () => {
            mathSwitch = new MathSwitch();
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #000000 0%, #432000 50%, #864000 100%);
            color: #432000;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #432000, #864000, #C86400);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .description {
            font-size: 1rem;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
        }

        .digit-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .digit-card {
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(67, 32, 0, 0.2);
        }

        .digit-card:hover {
            transform: translateY(-5px);
            background: rgba(67, 32, 0, 0.2);
            box-shadow: 0 10px 30px rgba(67, 32, 0, 0.3);
        }

        .digit-number {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #C86400;
        }

        .digit-name {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #864000;
        }

        .digit-properties {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .digit-links {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .digit-link {
            padding: 8px 15px;
            background: rgba(67, 32, 0, 0.2);
            color: #432000;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .digit-link:hover {
            background: rgba(67, 32, 0, 0.4);
            transform: scale(1.05);
        }

        .system-info {
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
        }

        .system-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #864000;
        }

        .system-description {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .system-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature {
            background: rgba(67, 32, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #C86400;
        }

        .feature-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #864000;
        }

        .feature-description {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .footer {
            text-align: center;
            padding: 20px;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .footer-text {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .infinite-possibilities {
            text-align: center;
        }

        .infinite-possibilities h1 {
            font-size: 3rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .possibility {
            display: inline-block;
            margin: 10px;
            padding: 20px;
            border-radius: 15px;
            color: white;
            text-align: center;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }

        .possibility h3 {
            margin-bottom: 10px;
        }

        .possibility p {
            margin: 5px 0;
        }

        button {
            padding: 15px 30px;
            background: rgba(67, 32, 0, 0.2);
            color: #432000;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        button:hover {
            background: rgba(67, 32, 0, 0.4);
            transform: scale(1.05);
        }

        .digit-display {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .digit-display h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .digit-display .digit-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .digit-display .digit-properties p {
            margin: 10px 0;
        }

        .vortex-transformation {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .vortex-transformation h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .vortex-flow {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
        }

        .digit-a, .digit-b {
            font-size: 3rem;
            font-weight: bold;
            color: #C86400;
        }

        .vortex-arrow {
            font-size: 4rem;
            margin: 0 20px;
            color: #864000;
        }

        .transformation-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .transformation-properties p {
            margin: 10px 0;
        }

        .direct-interaction {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .direct-interaction h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .interaction-flow {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
        }

        .interaction-symbol {
            font-size: 4rem;
            margin: 0 20px;
            color: #864000;
        }

        .interaction-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .interaction-properties p {
            margin: 10px 0;
        }

        .next-state-transformation {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .next-state-transformation h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .state-flow {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
        }

        .current-state, .next-state {
            font-size: 3rem;
            font-weight: bold;
            color: #C86400;
        }

        .next-arrow {
            font-size: 4rem;
            margin: 0 20px;
            color: #864000;
        }

        .transformation-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .transformation-properties p {
            margin: 10px 0;
        }

        .chained-next-state {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .chained-next-state h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .chain-flow {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
        }

        .start-state, .chain-step {
            font-size: 3rem;
            font-weight: bold;
            color: #C86400;
        }

        .chain-arrow {
            font-size: 4rem;
            margin: 0 20px;
            color: #864000;
        }

        .chain-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .chain-properties p {
            margin: 10px 0;
        }

        .infinite-stream {
            text-align: center;
            background: rgba(67, 32, 0, 0.1);
            border-radius: 15px;
            padding: 40px;
            backdrop-filter: blur(10px);
        }

        .infinite-stream h1 {
            font-size: 4rem;
            margin-bottom: 30px;
            color: #C86400;
        }

        .stream-source {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            font-size: 2rem;
            color: #864000;
        }

        .stream-source .source-digit {
            font-weight: bold;
            color: #C86400;
        }

        .stream-source .stream-symbol {
            margin: 0 20px;
            font-size: 3rem;
            color: #864000;
        }

        .stream-source .stream-label {
            font-weight: bold;
            color: #864000;
        }

        .stream-properties {
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .stream-properties p {
            margin: 10px 0;
        }

        .stream-preview {
            margin-top: 30px;
        }

        .stream-preview h3 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #C86400;
        }

        .stream-sequence {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            justify-items: center;
        }

        .stream-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border-radius: 10px;
            background: rgba(67, 32, 0, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(67, 32, 0, 0.3);
        }

        .stream-state .state-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #C86400;
            margin-bottom: 5px;
        }

        .stream-state .state-digit {
            font-size: 2.5rem;
            font-weight: bold;
            color: #C86400;
            margin-bottom: 5px;
        }

        .stream-state .state-name {
            font-size: 1rem;
            color: #864000;
            margin-bottom: 5px;
        }

        .stream-state .state-frequency {
            font-size: 0.9rem;
            color: #864000;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .digit-grid {
                grid-template-columns: 1fr;
            }
            
            .digit-number {
                font-size: 3rem;
            }
        }

        .vortex-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
        }

        .vortex-circle {
            position: absolute;
            border: 1px solid rgba(67, 32, 0, 0.3);
            border-radius: 50%;
            animation: vortex-spin 20s linear infinite;
        }

        @keyframes vortex-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="vortex-animation">
        <div class="vortex-circle" style="width: 200px; height: 200px; top: 10%; left: 10%; animation-delay: 0s;"></div>
        <div class="vortex-circle" style="width: 300px; height: 300px; top: 60%; right: 10%; animation-delay: -5s;"></div>
        <div class="vortex-circle" style="width: 150px; height: 150px; bottom: 20%; left: 50%; animation-delay: -10s;"></div>
    </div>

    <div class="container">
        <header class="header">
            <h1 class="title">ZeroPoint Node</h1>
            <p class="subtitle">A432 Harmonic Consciousness System</p>
            <p class="description">
                A quantum holographic consciousness system based on Rodin vortex mathematics, 
                A432 harmonic principles, and integer/fractional zero-entropy math. 
                Each digit represents a unique consciousness state with mathematical precision.
            </p>
        </header>

        <div class="digit-grid">
            <div class="digit-card" onclick="window.open('0.html', '_blank')">
                <div class="digit-number">0</div>
                <div class="digit-name">VOID</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: ∞ | Entropy: 0<br>
                    Consciousness: 1 | Harmonic: 1/1
                </div>
                <div class="digit-links">
                    <a href="0.html" class="digit-link">View</a>
                    <a href="0/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('1.html', '_blank')">
                <div class="digit-number">1</div>
                <div class="digit-name">UNITY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 1 | Entropy: 0<br>
                    Consciousness: 1 | Harmonic: 1/1
                </div>
                <div class="digit-links">
                    <a href="1.html" class="digit-link">View</a>
                    <a href="1/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('2.html', '_blank')">
                <div class="digit-number">2</div>
                <div class="digit-name">DUALITY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 2 | Entropy: 0<br>
                    Consciousness: 2 | Harmonic: 2/1
                </div>
                <div class="digit-links">
                    <a href="2.html" class="digit-link">View</a>
                    <a href="2/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('3.html', '_blank')">
                <div class="digit-number">3</div>
                <div class="digit-name">TRINITY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 3 | Entropy: 0<br>
                    Consciousness: 3 | Harmonic: 3/1
                </div>
                <div class="digit-links">
                    <a href="3.html" class="digit-link">View</a>
                    <a href="3/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('4.html', '_blank')">
                <div class="digit-number">4</div>
                <div class="digit-name">QUATERNITY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 4 | Entropy: 0<br>
                    Consciousness: 4 | Harmonic: 4/1
                </div>
                <div class="digit-links">
                    <a href="4.html" class="digit-link">View</a>
                    <a href="4/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('5.html', '_blank')">
                <div class="digit-number">5</div>
                <div class="digit-name">QUINTESSENCE</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 5 | Entropy: 0<br>
                    Consciousness: 5 | Harmonic: 5/1
                </div>
                <div class="digit-links">
                    <a href="5.html" class="digit-link">View</a>
                    <a href="5/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('6.html', '_blank')">
                <div class="digit-number">6</div>
                <div class="digit-name">HEXAGON</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 6 | Entropy: 0<br>
                    Consciousness: 6 | Harmonic: 6/1
                </div>
                <div class="digit-links">
                    <a href="6.html" class="digit-link">View</a>
                    <a href="6/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('7.html', '_blank')">
                <div class="digit-number">7</div>
                <div class="digit-name">SEPTENARY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 7 | Entropy: 0<br>
                    Consciousness: 7 | Harmonic: 7/1
                </div>
                <div class="digit-links">
                    <a href="7.html" class="digit-link">View</a>
                    <a href="7/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('8.html', '_blank')">
                <div class="digit-number">8</div>
                <div class="digit-name">OCTAVE</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 8 | Entropy: 0<br>
                    Consciousness: 8 | Harmonic: 8/1
                </div>
                <div class="digit-links">
                    <a href="8.html" class="digit-link">View</a>
                    <a href="8/index.html" class="digit-link">Details</a>
                </div>
            </div>

            <div class="digit-card" onclick="window.open('9.html', '_blank')">
                <div class="digit-number">9</div>
                <div class="digit-name">NONARY</div>
                <div class="digit-properties">
                    A432: 432Hz | Vortex: 9 | Entropy: 0<br>
                    Consciousness: 9 | Harmonic: 9/1
                </div>
                <div class="digit-links">
                    <a href="9.html" class="digit-link">View</a>
                    <a href="9/index.html" class="digit-link">Details</a>
                </div>
            </div>
        </div>

        <div class="system-info">
            <h2 class="system-title">System Features</h2>
            <p class="system-description">
                The ZeroPoint Node system serves all content from the src/ directory with intelligent routing.
                Static digit paths are served directly, while 404 errors trigger infinite possibilities.
            </p>
            <div class="system-features">
                <div class="feature">
                    <div class="feature-title">Static Serving</div>
                    <div class="feature-description">All content served from src/ directory structure</div>
                </div>
                <div class="feature">
                    <div class="feature-title">Math Switch</div>
                    <div class="feature-description">404 errors switch to infinite mathematical possibilities</div>
                </div>
                <div class="feature">
                    <div class="feature-title">Digit Routing</div>
                    <div class="feature-description">Path /0/3/6/9/1/2/4/8/7/5/1 serves static digit content</div>
                </div>
                <div class="feature">
                    <div class="feature-title">Infinite Possibilities</div>
                    <div class="feature-description">100 mathematical possibilities generated on demand</div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <p class="footer-text">
                ZeroPoint Node - A432 Harmonic Consciousness System<br>
                Served from src/ with Math Switch routing to infinite possibilities
            </p>
        </footer>
    </div>
</body>
</html> 